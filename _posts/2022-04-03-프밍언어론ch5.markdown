---
layout: post
title:  "프로그래밍 언어론 챕터 52"
date:   2022-04-11 14:49:24 +0900
categories: 프로그래밍언어론
---
## Chapter 5 Topics

- Introduction 명령
- Names 이름
- Variables 변수
- The Concept of Binding
- Scope
- Scope and Lifetime
- Referencing Environments
- Names Contants
---
## Introduction
- ### IMperative languages are abstractions of von Neumann archiecture<br>명령형 언어는 폰 노이만 구조의 추상화
  - Memory
  - Processor
- ### Variables are characterized by attribues<br>변수들은 속성을 통해서 특질화됨
  - to design a type, must consider scope, lifetime, type checking, initialiation, and type compatibility<br>데이터 타입을 설계하려면, 범위, 수명, 타입 검사, 초기화 및 타입 호환성을 고려해야 함
---
## Names
- ### 이름에 대한 설계 문제
  - 대소문자를 구분하는가?
  - 특수 예약어 혹은 키워드인가?
- ### 길이
  - 너무 짧으면 함축적일 수 없음
  - 예 :
    - C99 : 제한은 없지만 처음 63개만 중요. 또한 외부 이름은 최대 31로 제한
    - C# 및 자바: 제한 없음, 모두 유ㅡ의미함
    - C++ : 딱히 제안은 없지만 구현자는 종종 부과
- ### 특수문자
  - PHP: 모든 변수는 $자로 시작해야 함
  - Perl : 모든 변수명은 변수의 타입을 지정하는 특수문자로 시작해야 함
  - Ruby : @로 시작하는 변수명은 인스턴스 변수이며, @@로 시작하는 것은 클래스 변수이다.
- ### 대소문자 구분
  - 단점 : 가독성(비슷하게 생겨도 다르니까)
    - C언어 기반 언어들은 대소문자를 구분
    - 다른 언어들인 굳이 구분하진 않음
    - C++, Java 및 C#에서 사전 정의된 이름이 대소문자가 섞여 있으므로 더 심각함(예: IndexOutOfBoundsException)
- ### Special words
  - 가독성을 높이기 위한 보조 도구. 문장 절을 구분하거나 구분하는 데에 사용됨
  - 키워드는 특정 문맥에서만 특별한 단어
  - 예약어는 사용자 정의 이름으로 사용할 수 없는 특수 단어
  - 예약어의 잠재적인 문제 : 너무 많으면 충돌이 많이 발생하게 됨(cf, 코볼은 예약어만 300개를 가지고 있음)
---
## 변수
- ### 변수는 메모리 셀의 추상화
- ### 변수는 6개의 속성으로 특징지을 수 있음
  - 이름
  - 주소
  - 값
  - 타입
  - 수명
  - 범위
- ### 변수 - 이름
  - 일부 변수에는 해당되지 않음
- ### 주소
  - 연결된 메모리 주소
  - 변수는 실행 중에 서로 다른 시간에 다른 주소를 가질 수 있음
  - 변수가 프로그램의 여러 장소에서 다른 주소를 가질 수 있음
  - 두 개의 변수 이름을 사용하여 동일한 메모리 위치에 액세스할 수 있는 경우 별칭이라고 함
  - 별칭은 포인터, 참조 변수, C 및 C++의 공용체를 통해 생성
  - 별칭은 가독성에 유해함(읽는 사람들이 전부 기억해야 하므로)
- ### 타입
  - 변수의 값 범위와 해당 타입의 값에 대해 정의된 연산 집합을 결정. 
  - 부동 소수점의 경우 타입은 부동 소수점의 정밀도까지 결정
- ### 값
  - 변수가 연결된 위치의 내용
  - 변수의 l값은 해당 변수의 주소
  - 변수의 r값은 변수의 값
- ### 추상 메모리 셀
  - 변수와 연관된 실제 셀 또는 셀 모음
---
## 바인딩의 개념
- ### 바인딩은 변수와 해당 타입 또는 값 사이, 또는 연산과 기호 사이의 개체와 속성의 연결이다.
  - int x = 20은 x라는 이름에 int 타입과 값 20이 연관되는 것.
- ### 바인딩 시간은 바인딩이 수행되는 시간
- ### 바인딩 가능 시간
  - 언어 설계 시간 : 프로그래밍 언어를 정의할 때<br>연산자 기호를 연산에 바인딩<br>
  - 언어 구현 시간 : 언어에 대한 번역기를 구현할 때<br>부동 소수점 유형을 표현에 바인딩
  - 컴파일 시간 :<br>변수를 C 또는 JAVA 형식으로 바인딩
  - 런타임 :<BR>비정적 지역 변수를 메모리 셀에 바인딩
  - ### 정적 바인딩과 동적 바인딩
    - 실행 시간 전에 처음 일어나고 프로그램이 실행되는 동안 내내 변경되지 않으면 정적
    - 바인딩은 실행 중에 처음 일어나거나 프로그램 실행 중에 변경될 수 있으면 정적
## 타입 바인딩
- 타입은 어떻게 지정되는가?
- 바인딩인 언제 이루어지는가?
- 정적인 경우 유형은 명시적 또는 암묵적 선언으로 이루어질 수 있음
- ### 선언
  - 변수에 이름과 데이터 타입 등의 속성을 부여하는 문장.
- ### 명시적 선언, 암묵적 선언
  - 명시적 선언은 변수의 유형을 선언하는 데 사용되는 프로그램문<br>cf) int x;
  - 암묵적 선언은 선언문이 아닌 기본 규칙을 통해 변수 유형을 지정하는 기본 매커니즘
  - Basic, Perl, Ruby, JavaScript 및 PHP는 암묵적 선언을 제공함
  - 장점 : 작성 용이성(부차적 편의성)
  - 단점 : 안정성(Perl에서는 문제 적음)
  - 일부 언어는 형식 추론을 사용해 변수 유형(컨텍스트)를 결정함
    - C# : 변수는 var과 초기값으로 선언될 수 있고, 초기값이 타입을 결정
    - 비주얼 베이직 9.0+, ML, Haskell, f#은 타입 추론을 사용하고, 변수의 겉보기 문맥이 변수의 타입을 결정
## 동적 유형 바인딩
- ### 동적 유형 바인딩(자바스크립트, 파이썬, 루비, PHP 및 C#(제한있음))
- #### 할당문을 통해 지정됨
  - CF) 자바스크립트<BR>list = [2, 4.33, 6,  8];<br>list = 17.3;
  - 장점 : 유연성(일반 프로그램 단위)
  - 단점 :
    - 고비용(동적 유형 확인 및 해석)
    - 컴파일러를 통한 타입 오류 감지가 어려움
## 변수 특성
- ### 저장소 바인딩 및 수명
  - 할당 : 사용 가능한 셀을 가져오는 것
  - 할당 해제 : 셀을 다시 풀로 되돌려놓는 것
- ### 변수의 수명은 특정 메모리 셀에 바인딩된 시간
## 수명별 변수 범주
- ### 정적 변수
  - 실행이 시작되기 전 메모리 셀에 바인딩되고 실행 내내 동일한 메모리 셀에 바인딩된 상태로 유지됨
  - cf) C언어 C++ 함수 내 정적 변수들
    - 장점 : 효율성(직접 주소 지정), 기록에 민감한 하위 프로그램 지원
    - 단위 : 유연성 부족(재귀 사용 불가)
- ### 스택 - 동적
  - 변수를 위해 이루어지는 저장소 바인딩은 선언문이 정교해질때(관련된 실행 코드가 실행될 떄) 이루어짐
- ### 스칼라
  - 주소를 제외한 모든 속성들이 정적으로 바인딩됨
  - 장점 : 재귀 허용, 저장소 절약
  - 단점 :
    - 할당 및 할당 해제시에 오버헤드
    - 하위 프로그램은 기록을 구분할 수 없게 됨
    - 비효율적인 참조(간접 주소 지정)
- ### 명시적 동적 힙
  - 프로그래머가 지정한 명시적 지시자에 의해 할당 및 할당 해제되며, 실행중에 적용됨
  - C++의 동적 개체(새 개체 및 삭제를 통해)와 같은 포인터나 참조를 통해서만 참조되며, 자바의 모든 개체
  - 이점 : 동적 스토리지 관리 제공
  - 단점 : 비효율적이고 안정성이 부족
- ### 암묵적 동적 힙
  - 할당문으로 할당 및 할당 해제
  - APL의 모든 변수, Perl, 자바스크립트 및 PHP의 모든 문자열 및 배열
  - 단점 : 
    - 모든 특성이 동적이기 때문에 비효율적
    - 오류 감지 손실
---
## 변수 특성 : 범위
  - 변수의 범위는 해당 변수가 표시되는 문장의 범위
  - 프로그램 유닛의 지역 변수는 해당 유닛에 선언된 변수
  - 프로그램 유닛의 비지역 변수는 유닛에서 볼 수 있지만 유닛에서 선언되지 않은 변수
  - 전역 변수는 비지역 변수의 특수 범주
  - 언어의 범위 규칙은 이름에 대한 참조가 변수와 연결되는 방법을 결정함
## 정적 범위
- 프로그램 텍스크 기반
- 변수에 이름 참조를 연결하려면 사용자 또는 컴파일러가 선언을 찾아야 함
- 검색 프로세스 : 먼저 지역에서 선언을 검색한 다음, 지정된 이름에 대한 선언을 찾을 때까지 점점 더 큰 범위를 포함
- (특정 범위에 대한) 정적 스코프를 둘러싸는 것을 static ancestor라고 하며, 가장 가까운 정적 상위 항목을 static parent라고 함.
- 일부 언어는 중첩된 정적 범위(cf, Ada, 자바스크립트, Common Lisp, Scheme, Fortran 2003+, F+, 파이썬)을 생성하는 중첩된 서브프로그램 정의를 허용
- 변수는 같은 이름의 "가까운" 변수를 사용하여 유닛에서 숨길 수 있음
 - ### 블록
   - 프로그램 내부에 정적 범위를 만드는 방법
   - C의 예 :
```
void sub() {
    int count;
    while (...) {
        int count;
        count++;
        ...
    }
}
```
- 참고 :
  - C언어 및 C++에서는 잘 먹힘
  - 자바는 아님
  - C# : 오류 잦음