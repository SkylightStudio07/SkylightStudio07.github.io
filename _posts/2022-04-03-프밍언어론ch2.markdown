---
layout: post
title:  "프로그래밍 언어론 챕터 2"
date:   2022-04-10 14:49:24 +0900
categories: 프로그래밍언어론
---
## Chapter 2 Topics
- Zuse's Plankalkül
- 의사 코드
- IBM 704 / 포트란
- 함수형 프로그래밍 : LISP
- ALGOL 60
- 비즈니스 기록의 전산화 : 코볼
- 시분할의 시작 : 베이직
- 모두를 위한 모든 것 : PL/I
- 두 초기 동적 언어 : APL / SNOBOL
- 데이터 추상화의 시작 : SIMULA 67
- 직교적 디자인 : ALGOL 68
- 알골의 초기 계승자들
- 논리 기반 프로그래밍 : Prolog
- 역사의 가장 거대한 디자인 노력 : 에이다
- 객체 지향 프로그래밍 : Smalltalk
- 명령형 언어와 객체 지향 언어의 결합 : C++
- 함수형 언어 기반의 객체 지향 언어 : JAVA
- 스크립팅 언어들
- 새천년의 C 기반 언어 : C#
- 마크업/프로그래밍 하이브리드 언어들
---
## Zuse's Plankalkül
- ### 결코 구현되지 않았고, 이 언어의 몇가지 기능은 개발된지 15년이 지나서야 다른 언어에 나타나게 됨
- ### 특징
  - 부동소수점 표기는 2의 보수 표기법
  - 은폐 비트 기법
  - 스칼라 타입 외에도 배열과 레코드(C언어의 struct) 포함
  - goto문은 없지만 ada의 for문과 유사한 반복문을 포함했고, 루프를 탈출하는 fin 명렁어도 있었음
  - 프로그램 변수들 간의 현재 관계를 보여주는 수학적 표현식의 포함(자바의 assertion과 유사)
---
## 의사 코드
- ### 기계어의 문제점
  - 낮은 가독성
  - 낮은 수정성
  - 지루한 표현 코딩
  - 기계 결함 - 인덱싱 또는 부동소수점 없음
### 의사 코드 : 숏코드
    - 첫번째 의사코드. BINAC을 위해 개발되었고 나중에 유니박으로 옮겨짐. 알려진 바는 없지만 유니박을 위한 프로그래밍 매뉴얼은 남아 있음
    - 숏코드는 기계 코드로 번역되지 않았으며 그 대신 순수 인터프리터로 구현되었음. 그 당시 이런 과정을 자동 프로그래밍이라고 부름. 기계 코드보다 50배 느림
    - 왼쪽에서 오른쪽으로 코딩
    - Mauchly에 의해 1949년에 만들어짐
### 의사 코드 : 스피드코딩
    - Backus에 의해 1954년에 개발되었음. IBM 701용
    - 산술 및 산술 함수의 유사 연산
    - 조건부 및 무조건 분기
    - 배열 액세스를 위한 자동 증분 레지스터
    - 느림!
    - 사용자 프로그램에 700글자만 사용할 수 있었음
### 의사 코드 : 연관 시스템
    - 유니박 컴파일 시스템
      - 그레이스 호퍼가 이끄는 팀에 의해 개발
      - 기계어로 확장된 의사 코드
    - 데이비드 J. 윌러
      - 절대 주소 지정 문제를 해결하기 위해 재배치 가능한 주소 블록을 사용하는 방법을 개발함
---
## IBM 704와 포트란
- 컴퓨팅 분야의 가장 커다란 단일 발전 중 하나
- ### 포트란 0 : 1954
  - 구현되지 않았음
- ### 포트란 1 : 1957
  - 인덱스 레지스터와 부동 소수점을 갖춘 새로운 IBM 704용으로 설계됨
    - 이것은 컴파일된 프로그래밍 언어의 발상으로 이어졌음. 왜냐하면 해석 비용(부동 소수점 소프트웨어이 없었음)을 숨길 곳이 없었기 때문임
  - 개발된 주요 환경
    - 1) 컴퓨터의 메모리 용량이 작고 느리고 상대적으로 안정성이 부족했음
    - 2) 컴퓨터의 주요 사용이 과학 계산 분야를 위한 것이었음
    - 3) 컴퓨터를 프로그래밍하기 위한 달리 존재하는 효율적이고 효과적인 방법이 없었음
    - 4) 기계 효율성이 가장 큰 관심사였음
## 포트란의 디자인 과정
- ### 포트란 1이 가져온 환경에의 충격
  - 동적 저장소가 필요하지 않음
  - 우수한 배열 처리 및 카운팅 루프 필요
  - 문자열 처리, 소수점 연산 및 강력한 입출력(비즈니스 소프트웨어용) 없음
## 포트란 1 오버뷰
- ### 첫번째로 구현된 포트란
  - 이름은 최대 6글자까지 사용 가능
  - 테스트 후 카운트 루프(DO)
  - 형식화된 입출력
  - 사용자 정의 하위 프로그램
  - 삼원 선택문(산술 IF)
  - 데이터 입력문 없음
  - 별도의 컴파일 없음
  - 컴파일러는 1957년 4월에 출시
  - 400줄 보다 큰 프로그램들은 704의 안정성 문제때문에 제대로 컴파일되지 않았음
  - 코드가 매우 빠름
  - 빠르게 널리 사용되었음
  - 사용자 정의 서브루틴들, IF 선택문, DO루프문을 포함
  - 포트란의 모든 제어문은 704 명령어에 기반함
  - 포트란1 언어에 데이터 타입 문장이 존재하지 않아 IJKLMN으로 시작되는 변수는 묵시적으로 정수타입이고, 다른 모든 변수는 부동 소수점 타입임
  - 출시 전 컴파일러에 의해 생성되는 기계 코드가 직접 코딩으로 생성할 수 있는 코드가 절반 정도 효율적이라는 주장이 잠재적인 사용자들을 회의적으로 만들었으나 실제 출시 후 이 목표치를 거의 달성하여 매우 성공함.
## 포트란 2
- ### 1958년 배포, 포트란 1의 버그를 수정하고 몇가지 특징을 추가함
  - 서브루틴들의 독립적인 컴파일 기능<BR>그 전에는 프로그램의 어떤 변경도 전체 프로그램이 처음부터 다시 컴파일되었기에 704의 낮은 신뢰성과 더불어 프로그램 길이를 제한되게 만들어버렸음. 이제는 길게 프로그램을 짤 수 있게 됨
## 포트란 4
- ### 포트란 3은 개발되었으나 널리 배포되진 않고, 차후에 포트란 4가 히트함.
- ### 특징
  - 변수에 대한 명시적 타입 선언
  - 논리 IF문
  - 하위프로그램을 매개변수로서 다른 하위 프로그램에 전달할 수 있는 기능들이 포함됨
  - 1966년에 ANSI 표준화
## 평가

## LISP
- ### 인공지능의 시작과 리스트 처리
  - 연결 리스트에 포함된 기호 데이터를 처리하는 것을 허용하길 원했음
- ### 언어 개요
  - 순수 LISP은 원자 리스트 두 가지의 데이터구조를 가지며, 원소들은 식별자의 형식을 갖는 기호거나 수치 리터럴임
  - 함수형 프로그래밍 언어
  - 모든 계산들은 함수를 인자들에게 적용함으로써 이루어진다. 반복작업은 함수의 재귀로 사용
- ### 평기
  - 모든 AI 응용 영역 제패
  - 인터프리터도 쓰고 컴파일도 함
- ### 후손 언어
  - Scheme : LISP이 너무 광범위한 관계로 교육용으로 써임
  - Common LISP : 파생 LISP의 표준화
## ALGOL 60
  - 과학 응용 분야를 위한 언어
- ### 개요
  - ALGOL58, ALGOL 60 두번에 걸쳐 설계됨
  - 블록 구조 개념 도입
  - 서브프로그램에 매개변수를 전달하는 방법이 두가지 새로 생김(값전달, 이름전달)
  - 프로시저는 재귀적이게 허용
  - 스택-동적배열이 허용
## COBOL
  - 많이 사용되었으나 후속언어에 대한 영향은 미미
## 베이직
  - 시분할의 발단
  - 사용자 시간을 컴퓨터 시간보다 더욱 중요하게 고려해 이로 인해 시분할 개념을 도입
  - 판독성, 신뢰성 낮음
  - 
